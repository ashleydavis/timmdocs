---

title: Models API and Pretrained weights


keywords: fastai
sidebar: home_sidebar



nb_path: "nbs/00b_models.ipynb"
---
<!--

#################################################
### THIS FILE WAS AUTOGENERATED! DO NOT EDIT! ###
#################################################
# file to edit: nbs/00b_models.ipynb
# command to build the docs after a change: nbdev_build_docs

-->

<div class="container" id="notebook-container">
        
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="List-of-models-supported-by-timm">List of models supported by <code>timm</code><a class="anchor-link" href="#List-of-models-supported-by-timm"> </a></h2>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><code>timm</code> supports a wide variety of pretrained and non-pretrained models for number of Image based tasks.</p>
<p>To get a complete list of models, use the <code>list_models</code> function from <code>timm</code> as below. The <code>list_models</code> function returns a list of models ordered alphabetically that are supported by <code>timm</code>. We just look at the top-5 models below.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="kn">import</span> <span class="nn">timm</span> 

<span class="n">timm</span><span class="o">.</span><span class="n">list_models</span><span class="p">()[:</span><span class="mi">5</span><span class="p">]</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>[&#39;adv_inception_v3&#39;,
 &#39;cspdarknet53&#39;,
 &#39;cspdarknet53_iabn&#39;,
 &#39;cspresnet50&#39;,
 &#39;cspresnet50d&#39;]</pre>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>In general, you always want to use factory functions inside <code>timm</code>. Particularly, you want to use <code>create_model</code> function from <code>timm</code> to create any model. It is possible to create any of the models listed in <code>timm.list_models()</code> using the <code>create_model</code> function. There are also some wonderful extra features that we will look at later. But, let's see a quick example.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="kn">import</span> <span class="nn">random</span>
<span class="kn">import</span> <span class="nn">torch</span>

<span class="n">random_model_to_create</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">timm</span><span class="o">.</span><span class="n">list_models</span><span class="p">())</span>
<span class="n">random_model_to_create</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>&#39;resnet50d&#39;</pre>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">model</span> <span class="o">=</span> <span class="n">timm</span><span class="o">.</span><span class="n">create_model</span><span class="p">(</span><span class="n">random_model_to_create</span><span class="p">)</span>
<span class="n">x</span>     <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">224</span><span class="p">,</span> <span class="mi">224</span><span class="p">)</span>
<span class="n">model</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>torch.Size([1, 1000])</pre>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>In the example above, we randomly select a model name in <code>timm.list_models()</code>, create it and pass some dummy input data through the model to get some output. In general, you never want to create random models like this, and it's only an example to showcase that all models in <code>timm.list_models()</code> are supported by <code>timm.create_model()</code> function. It's really that easy to create a model using <code>timm</code>.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Does-timm-have-pretrained-weights-for-these-models?">Does <code>timm</code> have pretrained weights for these models?<a class="anchor-link" href="#Does-timm-have-pretrained-weights-for-these-models?"> </a></h2>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Of course! <code>timm</code> wants to make it super easy for researchers and practioners to experiment and supports a whole lot of models with pretrained weights. These pretrained weights are either:</p>
<ol>
<li>Directly used from their original sources</li>
<li>Ported by Ross from their original implementation in a different framework (e.g. Tensorflow models)</li>
<li>Trained from scratch using the included training script (<code>train.py</code>). The exact commands with hyperparameters to train these individual models are mentioned under <code>Training Scripts</code>.</li>
</ol>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>To list all the models that have pretrained weights, <code>timm</code> provides a convenience parameter <code>pretrained</code> that could be passed in <code>list_models</code> function as below. We only list the top-5 returned models.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">timm</span><span class="o">.</span><span class="n">list_models</span><span class="p">(</span><span class="n">pretrained</span><span class="o">=</span><span class="kc">True</span><span class="p">)[:</span><span class="mi">5</span><span class="p">]</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>[&#39;adv_inception_v3&#39;,
 &#39;cspdarknet53&#39;,
 &#39;cspresnet50&#39;,
 &#39;cspresnext50&#39;,
 &#39;densenet121&#39;]</pre>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>{% include note.html content='Just by listing the top-5 pretrained models, we can see that <code>timm</code> does not currently have pretrained weights for models such as <code>cspdarknet53_iabn</code> or <code>cspresnet50d</code>. This is a great opportunity for new contributors with hardware availability to pretrain the models on Imagenet dataset using the training script and share these weights. ' %}</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="My-dataset-doesn't-consist-of-3-channel-images---what-now?">My dataset doesn't consist of 3-channel images - what now?<a class="anchor-link" href="#My-dataset-doesn't-consist-of-3-channel-images---what-now?"> </a></h2>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>As you might already know, ImageNet data consists of 3-chanenl RGB images. Therefore, to be able to use pretrained weights in most libraries, the model expects a 3-channel input image.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="torchvision-raises-Exception"><code>torchvision</code> raises <code>Exception</code><a class="anchor-link" href="#torchvision-raises-Exception"> </a></h3>
</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="kn">import</span> <span class="nn">torchvision</span>

<span class="n">m</span> <span class="o">=</span> <span class="n">torchvision</span><span class="o">.</span><span class="n">models</span><span class="o">.</span><span class="n">resnet34</span><span class="p">(</span><span class="n">pretrained</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="c1"># single-channel image (maybe x-ray)</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">224</span><span class="p">,</span> <span class="mi">224</span><span class="p">)</span>

<span class="c1"># `torchvision` raises error</span>
<span class="k">try</span><span class="p">:</span> <span class="n">m</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>
<span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>Given groups=1, weight of size [64, 3, 7, 7], expected input[1, 1, 224, 224] to have 3 channels, but got 1 channels instead
</pre>
</div>
</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>As can be seen above, these pretrained weights from <code>torchvision</code> won't work with single channel input images. As a work around most practitioners convert their single channel input images to 3-channel images by copying the single channel pixels accross to create a 3-channel image.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Basically, <code>torchvision</code> above is complaining that it expects the input to have 3 channels, but got 1 channel instead.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1"># 25-channel image (maybe satellite image)</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span> <span class="mi">224</span><span class="p">,</span> <span class="mi">224</span><span class="p">)</span>

<span class="c1"># `torchvision` raises error</span>
<span class="k">try</span><span class="p">:</span> <span class="n">m</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>
<span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>Given groups=1, weight of size [64, 3, 7, 7], expected input[1, 25, 224, 224] to have 3 channels, but got 25 channels instead
</pre>
</div>
</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Again, <code>torchvision</code> raises an error and this time there is no workaround to get past this error apart from just not using pretrained weights and starting with randomly initialized weights.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="timm-has-a-way-to-handle-these-exceptions"><code>timm</code> has a way to handle these <code>exceptions</code><a class="anchor-link" href="#timm-has-a-way-to-handle-these-exceptions"> </a></h3>
</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">m</span> <span class="o">=</span> <span class="n">timm</span><span class="o">.</span><span class="n">create_model</span><span class="p">(</span><span class="s1">&#39;resnet34&#39;</span><span class="p">,</span> <span class="n">pretrained</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">in_chans</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

<span class="c1"># single channel image</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">224</span><span class="p">,</span> <span class="mi">224</span><span class="p">)</span>

<span class="n">m</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>torch.Size([1, 1000])</pre>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>We pass in a parameter <code>in_chans</code> to the <code>timm.create_model</code> function and this somehow just magically works! Let's see what happens with the 25-channel image?</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">m</span> <span class="o">=</span> <span class="n">timm</span><span class="o">.</span><span class="n">create_model</span><span class="p">(</span><span class="s1">&#39;resnet34&#39;</span><span class="p">,</span> <span class="n">pretrained</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">in_chans</span><span class="o">=</span><span class="mi">25</span><span class="p">)</span>

<span class="c1"># 25-channel image</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span> <span class="mi">224</span><span class="p">,</span> <span class="mi">224</span><span class="p">)</span>

<span class="n">m</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>torch.Size([1, 1000])</pre>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>This works again! :)</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="How-is-timm-able-to-use-pretrained-weights-and-handle-images-that-are-not-3-channel-RGB-images?">How is <code>timm</code> able to use pretrained weights and handle images that are not 3-channel RGB images?<a class="anchor-link" href="#How-is-timm-able-to-use-pretrained-weights-and-handle-images-that-are-not-3-channel-RGB-images?"> </a></h3>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><code>timm</code> does all this magic inside the <code>load_pretrained</code> function that get's called to load the pretrained weights of a model. Let's see how <code>timm</code> achieves loading of pretrained weights.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="kn">from</span> <span class="nn">timm.models.resnet</span> <span class="kn">import</span> <span class="n">ResNet</span><span class="p">,</span> <span class="n">BasicBlock</span><span class="p">,</span> <span class="n">default_cfgs</span>
<span class="kn">from</span> <span class="nn">timm.models.helpers</span> <span class="kn">import</span> <span class="n">load_pretrained</span>
<span class="kn">from</span> <span class="nn">copy</span> <span class="kn">import</span> <span class="n">deepcopy</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Below, we create a simple <code>resnet34</code> model that can take single channel images as input. We make this happen by passing in <code>in_chans=1</code> to the <code>ResNet</code> constructor class when creating the model.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">resnet34_default_cfg</span> <span class="o">=</span> <span class="n">default_cfgs</span><span class="p">[</span><span class="s1">&#39;resnet34&#39;</span><span class="p">]</span>
<span class="n">resnet34</span> <span class="o">=</span> <span class="n">ResNet</span><span class="p">(</span><span class="n">BasicBlock</span><span class="p">,</span> <span class="n">layers</span><span class="o">=</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">in_chans</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">resnet34</span><span class="o">.</span><span class="n">default_cfg</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">resnet34_default_cfg</span><span class="p">)</span>

<span class="n">resnet34</span><span class="o">.</span><span class="n">conv1</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>Conv2d(1, 64, kernel_size=(7, 7), stride=(2, 2), padding=(3, 3), bias=False)</pre>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">resnet34</span><span class="o">.</span><span class="n">conv1</span><span class="o">.</span><span class="n">weight</span><span class="o">.</span><span class="n">shape</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>torch.Size([64, 1, 7, 7])</pre>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>As we can see from the first convolution of <code>resnet34</code> above, the number of input channels is set to 1. And the <code>conv1</code> weights are of shape <code>[64, 1, 7, 7]</code>. This means that the number of input channels is 1, output channels is 64 and kernel size is <code>7x7</code>.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>But what about the pretrained weights? Because ImageNet consists of 3-channel input images, the pretrained for this <code>conv1</code> layer would be <code>[64, 3, 7, 7]</code>.Let's confirm that below:</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">resnet34_default_cfg</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>{&#39;url&#39;: &#39;https://github.com/rwightman/pytorch-image-models/releases/download/v0.1-weights/resnet34-43635321.pth&#39;,
 &#39;num_classes&#39;: 1000,
 &#39;input_size&#39;: (3, 224, 224),
 &#39;pool_size&#39;: (7, 7),
 &#39;crop_pct&#39;: 0.875,
 &#39;interpolation&#39;: &#39;bilinear&#39;,
 &#39;mean&#39;: (0.485, 0.456, 0.406),
 &#39;std&#39;: (0.229, 0.224, 0.225),
 &#39;first_conv&#39;: &#39;conv1&#39;,
 &#39;classifier&#39;: &#39;fc&#39;}</pre>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Let's load the pretrained weights from the model and check the number of input channels that <code>conv1</code> expects.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="kn">import</span> <span class="nn">torch</span>
<span class="n">state_dict</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">hub</span><span class="o">.</span><span class="n">load_state_dict_from_url</span><span class="p">(</span><span class="n">resnet34_default_cfg</span><span class="p">[</span><span class="s1">&#39;url&#39;</span><span class="p">])</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Great, so we have loaded the pretrained weights of resnet-34 from <code>'https://github.com/rwightman/pytorch-image-models/releases/download/v0.1-weights/resnet34-43635321.pth'</code> URL, let's now check the shape of the weights for <code>conv1</code> below:</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">state_dict</span><span class="p">[</span><span class="s1">&#39;conv1.weight&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>torch.Size([64, 3, 7, 7])</pre>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>So this layer expects the number of input channels to be 3!
{% include note.html content='We know this because the shape of <code>conv1.weight</code> is <code>[64, 3, 7, 7]</code>, this means that the number of input channels is <code>3</code>, output channels is <code>64</code> and the kernel size is <code>7x7</code>. ' %}{% include note.html content='This is why when we try to load pretrained weights, torchvision gives an error because our model&#8217;s <code>conv1</code> layer weights would be of shape <code>[64, 1, 7, 7]</code> because we set the number of input channels to be 1. I hope that this exception we saw above now makes more sense: <code>Given groups=1, weight of size [64, 3, 7, 7], expected input[1, 1, 224, 224] to have 3 channels, but got 1 channels instead.</code>' %}</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="So-how-is-timm-able-to-load-these-weights?">So how is <code>timm</code> able to load these weights?<a class="anchor-link" href="#So-how-is-timm-able-to-load-these-weights?"> </a></h3>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Something very clever happens inside the <code>load_pretrained</code> function inside <code>timm</code>. Basically, there's two main cases to consider when the expected number of input channels is not equal to 3. Either the input channels are 1 or not. Let's what happens in either case.</p>
<p>When the number of input channels is not equal to 3, then <code>timm</code> updates the <code>conv1.weight</code> of the pretrained weights accordingly to be able to load the pretrained weights.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h4 id="Case-1:-When-the-number-of-input-channels-is-1">Case-1: When the number of input channels is 1<a class="anchor-link" href="#Case-1:-When-the-number-of-input-channels-is-1"> </a></h4>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>If the number of input channels is 1, <code>timm</code> simply sums the 3 channel weights into a single channel to update the shape of <code>conv1.weight</code> to be <code>[64, 1, 7, 7]</code>. This can be achieved like so:</p>
<div class="highlight"><pre><span></span><span class="n">conv1_weight</span> <span class="o">=</span> <span class="n">state_dict</span><span class="p">[</span><span class="s1">&#39;conv1.weight&#39;</span><span class="p">]</span>
<span class="n">conv1_weight</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdim</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>

<span class="o">&gt;&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Size</span><span class="p">([</span><span class="mi">64</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">7</span><span class="p">])</span>
</pre></div>
<p>And thus by updating the shape of the first <code>conv1</code> layer, we can now safely load these pretrained weights.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h4 id="Case-2:-When-the-number-of-input-channels-is-not-1">Case-2: When the number of input channels is not 1<a class="anchor-link" href="#Case-2:-When-the-number-of-input-channels-is-not-1"> </a></h4>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>In this case, we simply repeat the <code>conv1_weight</code> as many times as required and then select the required number of input channels weights.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>{% include image.html alt="Pretrained Weights" width="500" class="center" max-width="500" file="/images/pretrained_weights.png" %}</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>As can be seen in the image above, let's say our input images have 8 channels. Therefore, number of input channels is equal to 8.</p>
<p>But, as we know our pretrained weights only have 3 channels. So how could we still make use of the pretrained weights?</p>
<p>Well, what happens in <code>timm</code> has been shown in the image above. We copy the weights 3 times such that now the total number of channels becomes 9 and then we select the first 8 channels as our weights for <code>conv1</code> layer.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>This is all done inside <code>load_pretrained</code> function like so:</p>
<div class="highlight"><pre><span></span><span class="n">conv1_name</span> <span class="o">=</span> <span class="n">cfg</span><span class="p">[</span><span class="s1">&#39;first_conv&#39;</span><span class="p">]</span>
<span class="n">conv1_weight</span> <span class="o">=</span> <span class="n">state_dict</span><span class="p">[</span><span class="n">conv1_name</span> <span class="o">+</span> <span class="s1">&#39;.weight&#39;</span><span class="p">]</span>
<span class="n">conv1_type</span> <span class="o">=</span> <span class="n">conv1_weight</span><span class="o">.</span><span class="n">dtype</span>
<span class="n">conv1_weight</span> <span class="o">=</span> <span class="n">conv1_weight</span><span class="o">.</span><span class="n">float</span><span class="p">()</span>
<span class="n">repeat</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">in_chans</span> <span class="o">/</span> <span class="mi">3</span><span class="p">))</span>
<span class="n">conv1_weight</span> <span class="o">=</span> <span class="n">conv1_weight</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">repeat</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[:,</span> <span class="p">:</span><span class="n">in_chans</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span>
<span class="n">conv1_weight</span> <span class="o">*=</span> <span class="p">(</span><span class="mi">3</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">in_chans</span><span class="p">))</span>
<span class="n">conv1_weight</span> <span class="o">=</span> <span class="n">conv1_weight</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">conv1_type</span><span class="p">)</span>
<span class="n">state_dict</span><span class="p">[</span><span class="n">conv1_name</span> <span class="o">+</span> <span class="s1">&#39;.weight&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">conv1_weight</span>
</pre></div>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Thus, as can be seen above, we first repeat the <code>conv1_weight</code> and then select required number of <code>in_chans</code> from these copied weights.</p>

</div>
</div>
</div>
</div>
 

